= Java EE
:author: Arnaud Tournier
:email: ltearno@gmail.com
:backend: revealjs
:deckjs_theme: neon
:revealjs_theme: beige
:revealjs_history: true
:imagesdir: images-javaee
:source-highlighter: highlightjs
////
:revealjs_transition: zoom
Java EE
2016 - LTE Consulting
:source-highlighter: pygments
////

== Java EE

**Définition**, serveur d'application.

Plateforme Java Enterprise Edition, sur ensemble de la plateforme standard.

Facilite le développement et le déploiement d'applications web distribuées exécutées au sein des serveurs d'application.

=== Quelques implémentations

JavaEE est une norme, il faut choisir l'implémentation : Tomcat, JBoss, Glassfish, ...

Application divisées en couches, souvent trois (presentation, business, data).

En pratique on a des pages htmls + servlets + jsp en frontal et ejb dans les couches internes (métier, processus et données).

=== Structure d'une application Java EE

```
/
|- fichiers publiques **.html**, **.jsp**, **.css**, **.js**, ...
|- WEB-INF/ (_cachés à l'utilisateur_)
  |- classes
    |- fichiers **.class**
  |- lib
    |- fichiers **.jar**
  |- **web.xml** : C'est un fichier de configuration de l'application
```

== Développement avec Eclipse

Installation de Tomcat, déclaration dans Eclipse, création d'un projet Dynamic Web Application et du serveur dans Eclipse.

Démarrage d'une application avec un fichier index.html dedans.

== HTTP

Rappels HTTP, requête, méthode (GET, POST), headers, cookies.

== Servlet

Une classe qui traite les requêtes HTTP.

=== Mise en place

Une servlet est une simple classe Java...

- Elle hérite de `javax.servlet.http.HttpServlet`,
- On implémente une des méthodes choisies `doGet`, `doPost` (l'implémentation par défaut renvoie une page 404).
- On indique au serveur quels sont l(es) URL(s) traitées par la servlet. Ceci se fait dans le fichier `web.xml` ou par annotation.

=== HttpServletRequest

Représente la requête

Paramètres, cookies

Attributs...

=== HttpServletResponse

Représente la réponse.

=== Cycle de vie

Le cycle de vie est géré par le serveur d'application (_d'où son nom_).

Celui-ci _crée_ et _détruit_ des instances de la classe.

=== Exemple

[source]
----
class MaServlet extends HttpServlet
{
	protected void doGet( HttpServletRequest r, HttpServletResponse re )
	{
		re.setContentType( "text/html; charset=utf8" );
		re.getWriter().print( "Hello world !" );
	}
}
----


== JSP

=== Définition

L'écriture de la vue (en HTML) est _pénible_ dans un fichier Java. Les `JSP` permet au contraire d'écrire en HTML et d'injecter du Java.

=== Fonctionnement

Vous écrivez des fichiers `.jsp`.

Ces fichiers sont compilés vers des servlets Java.

La servlet est accessible à l'URL correspondant au nom du fichier JSP (sauf quand il est dans `WEB-INF`).

Les variables `request`, `response` sont accessibles.

=== Exercice

Faire une page de login.


NOTE: Mettre `<%@ page pageEncoding="UTF-8" %>` pour utf8.

Poser du code : `<% ... %>`

Faire un echo : `<%= ... %>`

Commentaires : `<%-- ... --%>`

Directive : `<%@ page import="package.class"%>`, ...

=== Délégation 1

Délégation à partir d'une servlet :

[source]
----
void doGet( HttpServletRequest request, HttpServletResponse response )
{
	this.getServletContext()
		.getRequestDispatcher( "/WEB-INF/test.jsp" )
		.forward( request, response );
}
----

=== Délégation 2

Transmission d'information. Dans la servlet :

[source,language="java"]
----
request.setAttribute( "test", message );
----

Dans la JSP, on écrira :

[source,language="jsp"]
----
<% String attribut = (String) request.getAttribute("test"); out.println( attribut );%>
----

=== Formulaires

L'envoi de données au moment de la requête se fait grâce aux formulaires HTML.

Les valeurs des formulaires sont récupérées grâce à la méthode `getParameter( String name )` de la classe `HttpServletRequest`.

=== Méthode GET et POST

=== Pattern MVC

Le meilleur : peu de Java dans la JSP et peu de HTML dans le Java.

On arrive naturellement au pattern _MVC_ ou apparentés.

=== Les opérations CRUD

En exercice, implémenter sur un type de données :

- l'affichage (**D**isplay),
- la création de nouveaux éléments (**C**reate),
- la suppression d'éléments (**R**emove),
- la modification d'éléments (**U**pdate).

=== Les JSTL

Il est possible d'étendre le _vocabulaire_ des balises utilisables dans un ficher JSP.

Cette fonctionnalité est fournie par les _tag lib_ JSTL.

https://openclassrooms.com/courses/creez-votre-application-web-avec-java-ee/objectifs-et-configuration[OpenClassRooms]

=== Importation d'une tag lib

_Au préalable, il faut avoir le jar `jstl-1.2.jar` dans le projet_.

Import dans une JSP : `<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>`, ceci définit le _namespace_ XML `c`.

=== JSTL Exemple 1

Ceci est l'équivalent de la directive `<%@ include file="..." %>` :

[source]
----
<jsp:include page="<%= jspPageName %>" />
----

=== JSTL Exemple 2

Nous souhaitons réécrire le code suivant :

[source,language="jsp"]
----
<%
	List<Integer> list = (ArrayList<Integer>) request.getAttribute( "tirage" );
	for( int i = 0; i < list.size(); i++ ) {
		out.println( list.get( i ) );
	}
%>
----

=== JSTL Exemple 2

Voici l'équivalent avec la JSTL :

[source,language="jsp"]
----
<c:forEach var="i" begin="0" end="7" step="1"> <1>
  <tr>
    <td><c:out value="${i}"/></td> <2>
    <td><c:out value="${i * i * i}"/></td>
  </tr>
</c:forEach>
----
<1> le noeud `forEach` crée une variable EL `i`.
<2> la variable `i` est utilisée dans des expressions EL.

=== Expression Language

https://openclassrooms.com/courses/creez-votre-application-web-avec-java-ee/la-technologie-jsp-2-2[OpenClassRooms].

Quelques éléments du langage :

- `${ expression }` : _expression_ va être interprêtée...
- `${ true && true }` : ...
- `${ 10 mod 4 }` : ...
- `${ requestScope['nom'] }` : request.getAttribute( "nom" )
- `${ sessionScope['nom'] }` : session.getAttribute( "nom" )
- `${ param['id'] }` : request.getParameter( "id" )

=== EL exemple

[source]
----
<% 
List<String> legumes = new ArrayList<String>();
legumes.add( ... );
request.setAttribute( "legumes" , legumes );
%>

${ legumes.get(1) }
${ legumes[1] }
${ legumes["1"] }
----


=== Scope

JSP définit quatre _scopes_ (portées ou cycles de vie) pour les objets :

`application`, `session`, `request` et `page`.

Ceux-ci sont implémentés grâce aux attributs de requête, de session, et de contexte applicatif.

=== Scope

|===
|Portée | Servlet | JSP

|*application*
|`getServletContext()`
|`applicationScope[]`

|*session*
|`request.getSession()`
|`sessionScope[]`

|*request*
|`request`
|`requestScope[]`

|*page*
|-
|`pageScope[]`
|===

== JavaBean

Une convention pour exprimer la notion de _propriété_. En écriture et/ou lecture.

Exemple, la propriété `Longueur` :

[source,language="java"]
----
int getLongueur() { ... }
void setLongueur( int valeur ) { ... }
----

Il peut y avoir une notion d'abonnement (pattern _Observer_).

== JSF

=== Introduction

C'est un framework MVC pour simplifier l'écriture d'interface graphiques Web.

Fonctionne au dessus de l'api Servlet. Stable et utilisable depuis la version 2.0 en 2009.

Une seule servlet prend en charge toutes les requêtes et maintient l'état de la vue de _chaque_ client.

La programmation des vues repose sur _Facelet_, description XML des composants de la vue.

`javax.faces.webapp.FacesServlet`

La programmation des actions (_controlleur_) s'écrit dans des _Java Beans_.

`@ManagedBean`, `@RequestScoped`, `@ViewScoped`, `@SessionScoped`, `@ApplicationScoped`, `@CustomScope` et `@NoneScoped`...

Les données attachées aux échanges HTTP sont stockées dans des _Java Beans_ attachés aux différents scopes.

=== Avantage

Facilite la gestion conversationnelle grâce au modèle par composant.

Gère par ex. état des vues, maj des modèles, invocation des actions métiers, génération de la réponse, évènements, validation, internationnalisation...

=== Contrepartie

On ne maîtrise pas vraiment le HTML généré.

=== Structure d'une application JSF

- Vue : Facelet (un fichier *xhtml*),
- Modèle : entité JPA ou JavaBean,
- Controlleur : des `@ManagedBean`s

Configuration en plus de `web.xml` dans `faces-config.xml`.

=== Les fichiers Facelet

Ce ne sont que des fichiers XHTML (HTML conforme au XML). On utilise les extensions : **.jsf** ou **.xhtml** ou **.faces**.

Références des balises JSF : http://docs.oracle.com/javaee/6/javaserverfaces/2.1/docs/vdldocs/facelets/[ici], http://www.jsftoolbox.com/documentation/help/12-TagReference/index.jsf[ici] et sur http://stackoverflow.com/tags/jsf/info[stack overflow].

=== Exemple

[source,language="xml"]
----
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" 
	   xmlns:f="http://java.sun.com/jsf/core" 
	   xmlns:h="http://java.sun.com/jsf/html"
	   xmlns:ui="http://java.sun.com/jsf/facelets"> 
	<h:head>
		<title>Bienvenue</title>
		<h:outputStylesheet library="default" name="cartes.css"></h:outputStylesheet>
	</h:head>
	<h:body>
		<h:form>
			<h:inputText value="#{utilisateur.nom}" />
			<h:commandButton value="Valider" action="bienvenue" />
		</h:form>
	</h:body>
</html>
----

=== Expression Language pour JSF

L'évolution technique d'expression language fait que pour JSF, on utilise la syntaxe du type :

		#{inscrireBean.utilisateur.motDePasse}
		
On voit donc que `$` est remplacé par `#`. Ceci correspond au fait que l'expression language pour JSF permet d'appeler des *setters* sur les java beans, ce qui n'est pas permis avec `$`.

Depuis Java EE 6, expression language a été unifié et il est maintenant possible d'utiliser `#` dans les JSP.

=== Les 6 étapes du traitement d'une requête

- **Restauration de la vue** : si c'est un premier accès JSP crée une donnée de vue (l'arbre des composants) dans `FacesContext`. Sinon JSF recharge simplement les données de la vue.
- **Application des paramètres** de la requête : JSF fait automatiquement le lien entre les paramètres présents dans la requête et les champs du modèle à modifier.
- **Validation des données** : si la validation échoue, on passe directement à la dernière étape.
- **Mise à jour du modèle** : si la validation s'est bien déroulée, cette étape consiste à mettre à jour les données du modèle avec les données validées.
- **Appel au code métier** de l'application : les actions déclarées dans les formulaires sont exécutées, sous la forme d'appels aux méthodes des Beans.
- **Rendu de la réponse** : l'arbre des composants est appelé afin de générer le HTML résultat. Il est mémorisé pour la prochaine _Restauration de vue_.

=== Configuration

Dans `web.xml` on ajoute :

[source,language="xml"]
----
<context-param>
	<!-- autres noms possibles : STATE_SAVING_METHOD, INTERPRET_EMPTY_STRING_SUBMITTED_VALUES_AS_NULL ... -->
	<param-name>javax.faces.PROJECT_STAGE</param-name>
	<param-value>Development</param-value>
</context-param>

<servlet>
	<servlet-name>FacesServlet</servlet-name>
	<servlet-class>javax.faces.webapp.FacesServlet</servlet-class>
	<load-on-startup>1</load-on-startup>
</servlet>
<servlet-mapping>
	<servlet-name>FacesServlet</servlet-name>
	<url-pattern>*.xhtml</url-pattern>
</servlet-mapping>
----
		
=== Tutoriel

https://openclassrooms.com/courses/creez-votre-application-web-avec-java-ee/premiers-pas-avec-jsf

== Annexes

Les directives








Import d'un package : `<%@ page import="java.util.List, java.util.Date" %>`

Inclusion : `<%@ include file="uneAutreJSP.jsp" %>`

*Apparte* Scopes de vie : page / requete / session / application

Les tags `<jsp:useBean>`, `<jsp:getProperty>`,  `<jsp:setProperty>`, `<jsp:forward>`.

Les *expression language* : `${ monEjb.propriete }`

- JSTL

En JSP :

		<%@ page import="java.util.List, java.util.ArrayList" %>
		<%
		List<Integer> list = (ArrayList<Integer>)request.getAttribute("tirage");
		for(int i = 0; i < list.size();i++)
			out.println(list.get(i));
		%>

EN JSTL :

		<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>

		...

		<c:forEach var="item" items="${tirage}" >
			<c:out value="${item}" />
		</c:forEach>


[source]
----
mvn archetype:generate \
  -DarchetypeGroupId=fr.lteconsulting \
  -DarchetypeArtifactId=angular2-gwt.archetype \
  -DarchetypeVersion=1.1
  
mvn clean install

java -jar target/YOUR_ARTIFACT_ID.jar
----

[data-background="images/ingredients.jpg"]
== Ingrédients

== Architecture et Fonctionnement

[%notitle]
[data-transition=fade]
[data-background="images/archi-survol.png"]
[data-background-size=contain]
=== .

Tooo
