= Exercices Programmation Java
:author: Arnaud Tournier
:email: ltearno@gmail.com
:toc: macro
:toc-title: Exercices de programmation orientée objet avec Java
:source-highlighter: highlightjs
//// 
Mercredi 22 juin : implanter l'algorithme de tri naïf et l'algorithme de tri fusion sur un tableau d'entiers.
Jeudi 23 juin :

- calculer une factorielle
- palindromes
- jeu de Chifoumi

Vendredi 24 juin :

- Classe abstraite pour un animal
- Chaînage des constructeurs
- Polymorphisme

Mercredi 29 juin : les classes internes, anonymes...
Jeudi 30 juin : les exceptions
Vendredi 1er juillet : correction exceptions. les Collections
lundi 4 juillet
- pattern Commande (dur dur)
- Lecture/Ecriture fichier
mardi 5 juillet :
	détails sur pattern Commande (surement trop tot et trop compliqué pour en parler à ce stade)
	détails sur File et FileInputStream (juste lire et écrire des octets, pas des caractères)
mercredi 6 juillet : InputStreamReader avec encoding, html
jeudi 7 juillet : html / css (balises, flux, position static relative fixed)
vendredi 8 juillet : css (position absolute, overflow, clear, clear fix, flexbox, media queries, responsive design)
////


**QCM DISPONIBLE http://goo.gl/forms/7l9VP9dY5auWbZtj1[ICI] !!!**

LTE Consulting (C) - 2016

toc::[]

Ces exercices sont Open Source et sont disponibles en ligne : https://github.com/ltearno/formation-programmation-java[github.com/ltearno/formation-programmation-java]

== Exercices de base

_Connaissances de base du langage de programmation_

Voici un https://www.infres.telecom-paristech.fr/people/charon/coursJava/exercices/[lien] vers différents exercices.

Je vous propose de les réaliser dans l'ordre suivant :

- Calculer une factorielle
- Palindromes
- Implanter l'algorithme de tri naîf et l'algorithme de tri fusion sur un tableau d'entiers (celui-ci n'est pas dans le lien précédent).
- Classe abstraite pour un animal
- Chaînage des constructeurs
- Polymorphisme
- Jeu de Chifoumi

== Jeu de Cartes

_Connaissance des concepts de classe et d'héritage_

Vous vous intéressez dans cet exercice à décrire les données d'un jeu simulant des combats de magiciens.

Dans ce jeu, il existe trois types de cartes : les terrains, les créatures et les sortilèges.

- Les terrains possèdent une couleur (parmi 5 : `Blanc`, `Bleu`, `Noir`, `Rouge` et `Vert`. Pour ceci créez un enum `Couleur`).
- Les créatures possèdent un nom, un nombre de points de dégâts et un nombre de points de vie.
- Les sortilèges possèdent un nom et une explication sous forme de texte.

De plus, chaque carte, indépendamment de son type, possède un coût. Celui d'un terrain est 0.

Dans un nouveau projet nommé Magic, implémentez une hiérarchie de classes permettant de représenter des cartes de différents types.

Chaque classe aura un constructeur permettant de spécifier la/les valeurs de ses attributs.

Le programme doit utiliser la conception orientée objet et ne doit pas comporter de duplication de code.

Ajoutez ensuite aux cartes une méthode `afficher()` qui, pour toute carte, affiche son coût et la valeur de ses arguments spécifiques.

Créez de plus une classe `Jeu` pour représenter un jeu de cartes, c'est-à-dire une collection de telles cartes.

Cette classe devra avoir une méthode `piocher()` permettant d'ajouter une carte au jeu. On supposera qu'un jeu comporte au plus 10 cartes. Le jeu comportera également une méthode `joue()` permettant de jouer une carte. Pour simplifier, on jouera les cartes dans l'ordre où elles sont stockées dans le jeu, et on mettra la carte jouée à `null` dans le jeu de cartes.

Pour finir, dans la méthode `main(String[] args)`, constituez un jeu contenant divers types de cartes et faites afficher le jeu grâce à une méthode `afficher()` propre à cette classe.

Par exemple la méthode main pourrait ressembler à quelque chose comme cela  :

[source,language="java"]
----
class Magic {
	public static void main(String[] args) {
		Jeu maMain = new Jeu(10);
 
		maMain.piocher(new Terrain(Couleur.Bleu));
		maMain.piocher(new Creature(6, "Golem", 4, 6));
		maMain.piocher(new Sortilege(1, "Croissance Gigantesque", 
				"La créature ciblée gagne +3/+3 jusqu'à la fin du tour"));
 
		System.out.println("Là, j'ai en stock :");
		maMain.afficher();
		maMain.joue();
	}
}
----

qui produirait quelque chose comme :

	Là, j'ai en stock :
	Un terrain bleu
	Une créature Golem 4/6
	Un sortilège Croissance Gigantesque
	Je joue une carte...
	La carte jouée est :
	Un terrain bleu

== Créer une plateforme de jeux de plateau

Une classe `Plateau`

Une classe abstraite ou interface `Piece`

== Jeu bidon sur Plateau

_Saisie clavier, conception objet_

=== Première étape

Créer une classe JeuBidon :

- un attribut *privé* `plateau` de type `Plateau`
- une méthode *public* `jouer()`

Dans la méthode main, écrire

[source,language="java"]
----
JeuBidon jeu = new JeuBidon();
jeu.jouer();
----

=== Deuxième étape

Implémenter l'algorithme basique :

----
Poser la question : "Voulez-vous ajouter une pièce ?"
Si réponse est NON, fin de la méthode `jouer` (donc on fait return)
Si la réponse est OUI :
	Poser la question : "Quelle est l'abscisse ?"
	Poser la question : "Quelle est l'ordonnée ?"
	Placer une nouvelle pièce sur le plateau à l'endroit choisi par l'utilisateur.
	Afficher le tableau
	Recommencer
----

=== Etapes suivantes

Implémenter une méthode `Coordonnee saisieCoordonnee( String message )` qui renvoie directement un objet de type `Coordonnee`.

Permettre à l'utilisateur de saisir "5;3".

Permettre à l'utilisateur de saisir la couleur de la pièce à ajouter.

== Jeu de Puissance 4

_Saisie clavier, conception objet, algorithmique_

=== Etape 1 : création des classes

Créer une énumération `CouleurPuissance4` possédant deux valeurs : `Rouge` et `Jaune`. Cet enum représentera la couleur des jetons

Créer une classe `Jeton` avec :

- un attribut *privé* `nom` de type `String`
- un attribut *privé* `couleur` de type `CouleurPuissance4`
- le constructeur et les deux _getters_ des attributs `nom` et `couleur`.

Créer une classe `Puissance4` avec :

- un attribut *privé* `plateau` de type `Plateau`,
- une méthode *public* `jouer()`,
- une méthode *privée* `getPremiereLigneVide( int colonne )` qui retourne -1 si aucune cellule n'est vide dans la colonne passée en paramètre, et qui retourne l'index de la ligne à laquelle il _faudrait_ insérer le jeton.

=== Etape 2 : implémentation de l'algorithme

Dans la méthode `jouer()` de la classe `Puissance4`, implémenter l'algorithme suivant :

----
Saisir le nom du joueur 1
Saisir la couleur du joueur 1
Saisir le nom du joueur 2
Créer les deux instances de `Joueur` correspondants aux deux joueurs
TANT QUE (personne n'a gagné) ET QUE (le plateau n'est pas complètement rempli -> penser à implémenter une méthode Plateau.estPlein())
	Alterner le joueur
	Déclarer une variable `int ligneInsertion`
	Déclarer une variable `int colonneInsertion`
	FAIRE (correspond à une boucle do...while)
		Saisir la colonne d'insertion, stocker le résultat dans une variable `colonneInsertion`
		ligneInsertion = getPremiereLigneVide( colonneInsertion )
		SI ligneInsertion < 0
			AFFICHER MESSAGE : "La colonne est pleine, choisis-en une autre !"
		FIN SI
	TANT QUE( ligneInsertion < 0 )
	Placer la pièce à la coordonnée [colonneInsertion;ligneInsertion]
	Afficher le terrain
FIN TANT QUE
AFFICHER Math nul ou le gagnant
----

== Exercices avec les collections

_Connaissances des interfaces `List<T>`, `Set<T>` et `HashMap<K,V>`_

=== Exercice 1 : `List<T>`

- Instancier une `List<String>` avec la classe `ArrayList<T>`.
- Y stocker une dizaine de chaines de caractère.
- Parcourir la liste et afficher chaque chaine.
- Faire saisir à l'utilisateur un index, afficher la chaine stockée à l'index saisi.

=== Exercice 2 : `Set<T>`

- Instancier un `Set<T>` avec la classe `HashSet<T>`.
- Y stocker les chaines "bateau", "Bateau", "soleil", "bateau" et "fleur".
- Parcourir l'ensemble et afficher chaque chaine.
- Faire saisir à l'utilisateur un mot et indiquer si ce mot est présent dans l'ensemble. S'il n'est pas présent, le rajouter. Recommencer jusqu'à ce que l'utilisateur saisisse le mote "FIN" (peu importe la casse).

=== Exercice 3 : `Map<K, V>`

Le problème est d'associer une note à chaque exercice pour chaque étudiant.

Créez une classe `Exercice` qui représente un exercice donné (avec les attributs `intitule` et `sujet`).

Créez une classe `Etudiant` qui a deux attributs : `nom` (de l'étudiant) et `notes` (ses notes pour chaque exercice, vous aurez à réfléchir sur le type à utiliser).

Créez dans la classe `Etudiant` la méthode `void ajouterNote( Exercice exercice, int note )` qui enregistrera pour un étudiant la note obtenue à l'exercice donné.

Créez la méthode `void afficherNotes()` toujours dans la classe `Etudiant`, qui affiche le nom de l'étudiant ainsi que les notes obtenues aux exercices auquels il a participé.

Ecrire une classe avec une méthode `main` qui illustre que l'ensemble fonctionne de la façon attendue.

=== Exercice 4 : Les collections

_Utilisation des collections pour résoudre un problème concret_

On souhaite gérer une bibliothèque de disques audio.

Voici le diagramme des classes _à minima_, vous aurez bien sûr à ajouter des attributs et des méthodes selon la conception que vous aurez choisie !

Classe `Chanson` :

- attribut *privé* `nom` de type `String`,
- attribut *privé* `duree` de type `int` (durée de la chanson en secondes),
- constructeur et accesseurs.

Classe `Disque` :

- attribut *privé* `nom` de type `String`,
- attribut *privé* `codeBarre` de type `String`,
- attribut *privé* `chansons` de type `List<Chanson>`,
- constructeur et accesseurs,
- `addChanson( Chanson chanson )`,
- `getDuree()` retourne la durée totale du disque.

Classe `Bibliotheque` :

- les attributs nécessaires,
- `void ajouterDisque( Disque disque ) throws DisqueDejaPresentException`. Cette méthode provoque une exception `DisqueDejaPresentException` (que vous définirez) lorsqu'on ajoute un disque dont le code barre est déjà enregistré dans la bibliothèque.
- `boolean retirerDisque( String codeBarre )` qui retourne `true` si le disque a bien été retiré,
- `getNbDisques()`,
- `getDisque( String codeBarre )`,
- `List<Disque> rechercherDisques( String recherche )` : retourne la liste des disques dont le nom contient la chaîne `recherche`, peu importe la casse.
- `List<Chanson> rechercherChansons( String recherche )` : retourne la liste des chansons dont le titre contient `recherche` (sans prendre la casse en compte).

On considère qu'une fois ajouté à la bibliothèque, les disques et leurs chansons ne changent pas.

Commencez par implémenter les classes ci-dessus.

Puis proposez une interface en ligne de commande qui permette à l'utilisateur :

- de consulter la bibliothèque (chercher les disques par nom). En tapant une recherche il obtiendra la liste des disques correspondant ainsi que leur code barre.
- de consulter les détails d'un disque : en tapant le code barre du disque, il obtient la liste des chansons (nom de la chanson + durée).
- chercher des chansons : en tapant une recherche l'utilisateur reçoit les chansons avec le titre recherché, ainsi que le code barre du disque qui la contient.

==== Exercice 5

Continuer l'exercice précedent en chargeant la liste des disques et chansons à partir d'un fichier.